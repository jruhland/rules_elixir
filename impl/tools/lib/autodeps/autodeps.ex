defmodule Mix.Tasks.Autodeps do
  use Mix.Task
  alias RulesElixir.Tools.{Common, Bazel}

  @moduledoc """
  Generate BUILD files for the mix project in the current directory
  """
  @switches [prefix: :string,
	     echo: :boolean,
	     dry_run: :boolean,
	    ]

  # put our autogenerated rule in a separate file so you can build additional stuff.
  @auto_build_file "BUILD.autogenerated.bzl"
  @auto_macro "autogenerated_targets"
  @build_file_incantation """
  load(":#{@auto_build_file}", "#{@auto_macro}")
  #{@auto_macro}()
  """
  @auto_prolog """
  load("//impl:defs.bzl", "elixir_library", "elixir_script")
  """

  @impl true
  def run(args) do
    options = parse_args(args)
    Mix.Project.get!()
    :ets.new(:found_deps, [:set, :public, :named_table])
    {:ok, mixfile} = Common.active_mixfile()
    Process.put(:workspace_root, System.get_env("BUILD_WORKSPACE_DIRECTORY"))
    Mix.Task.run("autodeps.recursive")
    read_deps(Path.dirname(mixfile), options)
  end

  defp parse_args(args) do
    {parsed, positional, invalid} =  OptionParser.parse(args, strict: @switches)
    if Enum.count(positional) > 0 do
      IO.puts("warning: positional args unsupported: #{inspect(positional)}")
    end
    if Enum.count(invalid) > 0 do
      IO.puts("warning: invalid arguments: #{inspect(invalid)}")
    end
    parsed
  end

  defp read_deps(project_root, opts) do
    echo? = Keyword.get(opts, :echo, false)
    dry_run? = Keyword.get(opts, :dry_run, false)
    # use 2 ets tables to avoid filter?
    :ets.match(:found_deps, :"$1")
    |> Enum.filter(fn [{file, _, _}] -> is_binary(file) end)
    |> Enum.map(fn [{file, compile_dep_modules, runtime_dep_modules}] ->
      build_dir = Path.dirname(Path.relative_to(file, project_root))
      basename = Path.basename(file)
      {build_dir,       
       [name: Path.rootname(basename),
	srcs: [basename],
	compile_deps: modules_to_targets(file, compile_dep_modules),
	runtime_deps: modules_to_targets(file, runtime_dep_modules),
	visibility: ["//visibility:public"],
       ]}
    end)
    |> Enum.group_by(fn {dir, _} -> dir end, fn {_, attrs} -> attrs end)
    |> Enum.map(fn {dir, rule_attrs} ->
      rules = 
      rule_attrs
      |> Enum.sort_by(fn attrs -> Keyword.get(attrs, :name) end)
      |> Enum.map(fn attrs ->
	%Bazel.Rule{rule: "elixir_library", params: attrs}
      end)
      build_file_iodata = Bazel.to_iodata([@auto_prolog,
                                           %Bazel.Def{name: @auto_macro, body: rules}])
      auto_file_name = "#{dir}/#{@auto_build_file}"
      build_file_name = "#{dir}/BUILD"
      write_build_file? = not File.exists?(build_file_name)
      if not dry_run? do
	File.write!(auto_file_name, build_file_iodata)
        if write_build_file? do
          File.write!(build_file_name, @build_file_incantation)
        end
      end
      if echo? do
	IO.puts(["### ", auto_file_name, ":\n", build_file_iodata, "\n"])
        if write_build_file? do
          IO.puts(["### ", build_file_name, ":\n", @build_file_incantation, "\n"])
        end
      end
    end)
  end
      
  defp modules_to_targets(file, modules) do
    modules
    |> Enum.flat_map(fn module ->
      case :ets.lookup(:found_deps, module) do
	[{_, _project, dep_file}] when file != dep_file -> [dep_file]
        _ -> []
      end
    end)
    |> Enum.uniq
    |> Enum.map(fn dep_file ->
      if Path.dirname(dep_file) == Path.dirname(file) do
	# sort sibling deps first
	{0, sibling_target(dep_file)}
      else
	{1, qualified_target(dep_file)}
      end
    end)
    |> Enum.sort
    |> Enum.map(fn {_sort, target} -> target end)
  end

  defp sibling_target(file) do
    ":" <> Path.rootname(Path.basename(file))
  end

  defp qualified_target(file) do
    path_to_target(Path.relative_to(file, Process.get(:workspace_root)))
  end

  defp path_to_target(file) do
    dir = Path.dirname(file)
    file = Path.rootname(Path.basename(file))

    "//" <> Enum.join(Path.split(dir), "/") <> ":" <> file
  end
end

