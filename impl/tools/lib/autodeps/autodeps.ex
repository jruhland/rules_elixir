defmodule Mix.Tasks.Autodeps do
  use Mix.Task
  alias RulesElixir.Tools.{Common, Bazel, ReadMix}

  @moduledoc """
  Generate BUILD files for the mix project in the current directory
  """
  @switches [
    prefix: :string,
    echo: :boolean,
    dry_run: :boolean,
    overwrite: :boolean,
  ]

  # put our autogenerated rule in a separate file so you can build additional stuff
  @auto_build_file "BUILD.autogenerated.bzl"
  @auto_macro "autogenerated_targets"
  @load_elixir_rules """
  load("@rules_elixir//impl:defs.bzl", "elixir_library", "elixir_script", "mix_project")
  """
  @build_file_boilerplate """
  load(":#{@auto_build_file}", "#{@auto_macro}")
  # #{@load_elixir_rules}
  #{@auto_macro}()
  """

  @impl true
  def run(args) do
    options = parse_args(args)
    Mix.Project.get!()

    # Tuples {file, compile_dep_modules, runtime_dep_modules}
    :ets.new(:found_deps, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {module, file}
    :ets.new(:module_location, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {file, defines_macros?}
    :ets.new(:file_info, [:set, :public, :named_table, {:write_concurrency, true}])

    {:ok, mixfile} = Common.active_mixfile()
    project_dir = Path.dirname(mixfile)
    project = Mix.Project.config

    umbrella_target = Mix.Project.umbrella?(project) && Common.qualified_target(project_dir)
    Mix.Task.run("autodeps.recursive", Keyword.put(options, :umbrella, umbrella_target))

    generate_build_files(project_dir, options)

    all_targets =
      :ets.match(:found_deps, :"$1")
      |> Enum.map(fn [{file, _, _}] ->
        Path.rootname(file)
      end)

    Mix.Project.config
    |> ReadMix.project_build_file(all_targets)
    |> write_generated_body(project_dir, options)

  end

  defp parse_args(args) do
    {parsed, positional, invalid} =  OptionParser.parse(args, strict: @switches)
    if positional != [] do
      IO.puts("warning: positional args unsupported: #{inspect(positional)}")
    end
    if invalid != [] do
      IO.puts("warning: invalid arguments: #{inspect(invalid)}")
    end
    parsed
  end

  defp generate_build_files(project_root, opts) do
    :ets.match(:found_deps, :"$1")
    |> Enum.map(fn [{file, compile, runtime}] ->
      {Path.dirname(Path.relative_to(file, project_root)),
       %Bazel.Rule{rule: "elixir_library",
                   params: elixir_library_attrs(file, compile, runtime)}}
    end)
    |> Enum.group_by(fn {dir, _} -> dir end, fn {_, attrs} -> attrs end)
    |> Enum.map(fn {dir, rules} ->
      rules
      |> Enum.sort_by(fn rule -> Keyword.get(rule.params, :name) end)
      |> write_generated_body(dir, opts)
    end)
  end

  defp elixir_library_attrs(file, compile_deps, runtime_deps) do
    basename = Path.basename(file)
    defines_macros? = not Enum.empty?(:ets.lookup(:file_info, file))
    runtime_deps = modules_to_targets(file, runtime_deps)

    [
      name: Path.rootname(basename),
      srcs: [basename],
      compile_deps: modules_to_targets(file, compile_deps),
      runtime_deps: runtime_deps,
      macroexpand_deps: (if defines_macros?, do: runtime_deps, else: []),
      visibility: ["//visibility:public"],
    ]
  end

  defp write_generated_body(body, dir, opts) do
    [
      @load_elixir_rules,
      %Bazel.Def{name: @auto_macro, body: List.wrap(body)},
      "\n",
    ]
    |> Bazel.to_iodata
    |> Common.output_file("#{dir}/#{@auto_build_file}", Keyword.put(opts, :overwrite, true))
    
    Common.output_file(@build_file_boilerplate, "#{dir}/BUILD", opts)
  end


  defp modules_to_targets(file, modules) do
    modules
    |> Enum.flat_map(fn module ->
      case :ets.lookup(:module_location, module) do
        [{_, dep_file}] when dep_file != file -> [dep_file]
        _ -> []
      end
    end)
    |> Enum.uniq
    |> Enum.map(fn dep_file ->
      if Path.dirname(dep_file) == Path.dirname(file) do
	# sort sibling deps first
	{0, Common.sibling_target(dep_file)}
      else
	{1, Common.qualified_target(dep_file)}
      end
    end)
    |> Enum.sort
    |> Enum.map(fn {_sort, target} -> target end)
  end

end

