defmodule Mix.Tasks.Autodeps do
  use Mix.Task
  alias RulesElixir.Tools.{Common, Bazel}

  @moduledoc """
  Generate BUILD files for the mix project in the current directory
  """
  @switches [prefix: :string,
	     echo: :boolean,
	     dry_run: :boolean,
             overwrite: :boolean,
	    ]

  # put our autogenerated rule in a separate file so you can build additional stuff
  @auto_build_file "BUILD.autogenerated.bzl"
  @auto_macro "autogenerated_targets"
  @load_elixir_rules """
  load("@rules_elixir//impl:defs.bzl", "elixir_library", "elixir_script")
  """
  @build_file_boilerplate """
  load(":#{@auto_build_file}", "#{@auto_macro}")
  # #{@load_elixir_rules}
  #{@auto_macro}()
  """

  @impl true
  def run(args) do
    options = parse_args(args)
    Mix.Project.get!()

    # Tuples {file, compile_dep_modules, runtime_dep_modules}
    :ets.new(:found_deps, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {module, file}
    :ets.new(:module_location, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {file, defines_macros?}
    :ets.new(:file_info, [:set, :public, :named_table, {:write_concurrency, true}])

    {:ok, mixfile} = Common.active_mixfile()
    Process.put(:workspace_root, System.get_env("BUILD_WORKSPACE_DIRECTORY"))
    Mix.Task.run("autodeps.recursive")
    generate_build_files(Path.dirname(mixfile), options)
  end

  defp parse_args(args) do
    {parsed, positional, invalid} =  OptionParser.parse(args, strict: @switches)
    if positional != [] do
      IO.puts("warning: positional args unsupported: #{inspect(positional)}")
    end
    if invalid != [] do
      IO.puts("warning: invalid arguments: #{inspect(invalid)}")
    end
    parsed
  end

  defp generate_build_files(project_root, opts) do
    :ets.match(:found_deps, :"$1")
    |> Enum.map(fn [{file, compile, runtime}] ->
      {Path.dirname(Path.relative_to(file, project_root)),
       %Bazel.Rule{rule: "elixir_library",
                   params: elixir_library_attrs(file, compile, runtime)}}
    end)
    |> Enum.group_by(fn {dir, _} -> dir end, fn {_, attrs} -> attrs end)
    |> Enum.map(fn {dir, rules} ->
      rules
      |> Enum.sort_by(fn rule -> Keyword.get(rule.params, :name) end)
      |> generated_build_file
      |> Bazel.to_iodata
      |> output_file("#{dir}/#{@auto_build_file}", Keyword.put(opts, :overwrite, true))

      output_file(@build_file_boilerplate, "#{dir}/BUILD", opts)
    end)
  end

  defp elixir_library_attrs(file, compile_deps, runtime_deps) do
    basename = Path.basename(file)
    #macro_modules_in_file = :ets.match(:module_location, {:"$1", file, true})

    defines_macros? = not Enum.empty?(:ets.lookup(:file_info, file))
    IO.puts("#{basename} defines_macros? #{defines_macros?}")
    runtime_deps = modules_to_targets(file, runtime_deps)

    [name: Path.rootname(basename),
     srcs: [basename],
     compile_deps: modules_to_targets(file, compile_deps),
     # runtime_deps: runtime_deps,
     runtime_deps: (if defines_macros?, do: runtime_deps, else: []),
     visibility: ["//visibility:public"]]
  end

  defp generated_build_file(body) do
    [@load_elixir_rules,
     %Bazel.Def{name: @auto_macro, body: body
                # ["v = {\"hi\": True, \"hello\": True}" | body]
     }]
  end
      
  defp modules_to_targets(file, modules) do
    modules
    |> Enum.flat_map(fn module ->
      case :ets.lookup(:module_location, module) do
        [{_, dep_file}] when dep_file != file -> [dep_file]
        _ -> []
      end
    end)
    |> Enum.uniq
    |> Enum.map(fn dep_file ->
      if Path.dirname(dep_file) == Path.dirname(file) do
	# sort sibling deps first
	{0, sibling_target(dep_file)}
      else
	{1, qualified_target(dep_file)}
      end
    end)
    |> Enum.sort
    |> Enum.map(fn {_sort, target} -> target end)
  end

  defp sibling_target(file) do
    ":" <> Path.rootname(Path.basename(file))
  end

  defp qualified_target(file) do
    path_to_target(Path.relative_to(file, Process.get(:workspace_root)))
  end

  defp path_to_target(file) do
    dir = Path.dirname(file)
    file = Path.rootname(Path.basename(file))

    "//" <> Enum.join(Path.split(dir), "/") <> ":" <> file
  end

  defp output_file(contents, filename, opts) do
    write? = Keyword.get(opts, :overwrite, false) or not File.exists?(filename)
    if not Keyword.get(opts, :dry_run, false) do
      if write?, do: File.write!(filename, contents)
    end
    if write? and Keyword.get(opts, :echo, false) do
      IO.puts(["### ", filename, ":\n", contents, "\n"])
    end
  end
end

