defmodule Mix.Tasks.Autodeps do
  use Mix.Task
  alias RulesElixir.Tools.{Common, Bazel, ReadMix}

  @moduledoc """
  Generate BUILD files for the mix project in the current directory
  """
  @switches [
    prefix: :string,
    echo: :boolean,
    dry_run: :boolean,
    overwrite: :boolean,
  ]

  # put our autogenerated rule in a separate file so you can build additional stuff
  @auto_build_file "BUILD.autogenerated.bzl"
  @auto_macro "autogenerated_targets"
  @load_elixir_rules """
  load("@rules_elixir//impl:defs.bzl", "elixir_library", "elixir_script", "mix_project")
  """
  @build_file_boilerplate """
  load(":#{@auto_build_file}", "#{@auto_macro}")
  # #{@load_elixir_rules}
  #{@auto_macro}()
  """

  @impl true
  def run(args) do
    options = parse_args(args)
    Mix.Project.get!()

    # Tuples {file, compile_dep_modules, runtime_dep_modules}
    :ets.new(:found_deps, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {module, file}
    :ets.new(:module_location, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {file, app}
    :ets.new(:file_to_app, [:set, :public, :named_table, {:write_concurrency, true}])

    # Tuples {file, defines_macros?}
    :ets.new(:file_info, [:set, :public, :named_table, {:write_concurrency, true}])

    {:ok, mixfile} = Common.active_mixfile()
    project_dir = Path.dirname(mixfile)
    project = Mix.Project.config

    Process.put(:build_path, Mix.Project.build_path(project))

    umbrella_target = Common.qualified_target(project_dir)
    app = to_string(project[:app])
    Process.put(:third_party_target,
      Common.qualified_target("#{project_dir}/#{app}_third_party")
    )
    Process.put(:config_target,
      Common.qualified_target("#{project_dir}/config")
    )

    Mix.Task.run("autodeps.recursive", Keyword.put(options, :umbrella, umbrella_target))

    generate_build_files(project_dir, options)

    targets_by_app =
      :ets.match(:file_to_app, :"$1")
      |> Enum.map(fn [{file, app}] ->
	{to_string(app), Common.qualified_target(file)}
      end)
      |> Enum.group_by(&elem(&1, 0), &elem(&1, 1))

    Mix.Project.config
    |> ReadMix.project_build_file(targets_by_app)
    |> write_generated_body(project_dir, options)

  end

  defp parse_args(args) do
    {parsed, positional, invalid} =  OptionParser.parse(args, strict: @switches)
    if positional != [] do
      IO.puts("warning: positional args unsupported: #{inspect(positional)}")
    end
    if invalid != [] do
      IO.puts("warning: invalid arguments: #{inspect(invalid)}")
    end
    parsed
  end

  defp generate_build_files(project_root, opts) do
    :ets.match(:found_deps, :"$1")
    |> Enum.map(fn [{file, compile, runtime}] ->
      {Path.dirname(Path.relative_to(file, project_root)),
       %Bazel.Rule{rule: "elixir_library",
                   params: elixir_library_attrs(file, compile, runtime)}}
    end)
    |> Enum.group_by(fn {dir, _} -> dir end, fn {_, attrs} -> attrs end)
    |> Enum.map(fn {dir, rules} ->
      rules
      |> Enum.sort_by(fn rule -> Keyword.get(rule.params, :name) end)
      |> write_generated_body(dir, opts)
    end)
  end

  defp elixir_library_attrs(file, compile_deps, runtime_deps) do
    basename = Path.basename(file)
    defines_macros? = not Enum.empty?(:ets.lookup(:file_info, file))
    runtime_deps = modules_to_targets(file, runtime_deps)

    [
      name: Path.rootname(basename),
      srcs: [basename],
      compile_deps: modules_to_targets(file, compile_deps, include_third_party: true),
      #runtime_deps: runtime_deps,
      exported_deps: (if defines_macros?, do: runtime_deps, else: nil),
      visibility: ["//visibility:public"],
    ]
  end

  defp write_generated_body(body, dir, opts) do
    [
      @load_elixir_rules,
      %Bazel.Def{name: @auto_macro, body: List.wrap(body)},
      "\n",
    ]
    |> Bazel.to_iodata
    |> Common.output_file("#{dir}/#{@auto_build_file}", Keyword.put(opts, :overwrite, true))
    
    Common.output_file(@build_file_boilerplate, "#{dir}/BUILD", opts)
  end

  defp mix_dep_target(module, file) do
    buildpath = Process.get(:build_path)
    len = byte_size(buildpath)

    # Hack this for now
    case to_string(file) do
      <<prefix::binary-size(len), "/lib/", _rest::binary>> when prefix == buildpath ->
	{:ok, Process.get(:third_party_target)}
      x when module == Application ->
	{:ok, Process.get(:config_target)}
      x when module == :application ->
	{:ok, Process.get(:config_target)}
      _ ->
	:error
    end
  end

  defp modules_to_targets(file, modules, opts \\ []) do
    include_third_party? = Keyword.get(opts, :include_third_party, false)
    modules
    |> Enum.flat_map(fn module ->

      case :ets.lookup(:module_location, module) do
        [{_, dep_file}] when dep_file != file -> [dep_file]
        _ ->
	  with\
	  true <- include_third_party?,
	  {:file, f} <- :code.is_loaded(module),
	  {:ok, target} <- mix_dep_target(module, f)
	    do [target]
	    else _ -> []
	  end
      end
    end)
    |> Enum.uniq
    |> Enum.map(fn dep_file ->
      cond do
	Path.dirname(dep_file) == Path.dirname(file) ->
	  # sibling deps first
	  {0, Common.sibling_target(dep_file)}
	String.starts_with?(dep_file, "//") ->
	  # already a target, third pary dep, sort last
	  {2, dep_file}
	true ->
	  {1, Common.qualified_target(dep_file)}
      end
    end)
    |> Enum.sort
    |> Enum.map(fn {_sort, target} -> target end)
  end

end

