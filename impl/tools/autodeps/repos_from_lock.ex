defmodule RulesElixir.Tools.Autodeps.ReposFromLock do
  @moduledoc """
  Generates repository rule declarations for all of the deps in a mix.lock file.  
  This tool runs once for the entire monorepo and needs to know about every mix.exs.
  Use like this:
  $ git ls-files | egrep '(/|^)mix.exs$' | bazel run @rules_elixir//impl/tools:repos_from_lock --  --output bazel/elixir_auto_repos.bzl
  """
  @switches [
    output: :string, # interpreted relative to workspace root
    workspace_name: :string,
    workspace_root: :string,
  ]

  alias RulesElixir.Tools.Bazel
  alias RulesElixir.Tools.Autodeps.{Labeler, BuildWriter, LockIndexer}

  def main(argv) do
    {opts, run_in_mix_envs} = OptionParser.parse!(argv, strict: @switches)

    case System.get_env("BUILD_WORKSPACE_DIRECTORY") do
      nil -> :not_in_bazel_run
      bwd -> File.cd!(bwd)
    end
    output_bzl = Path.absname(opts[:output])

    {:ok, _sup} = Supervisor.start_link([
      Labeler.child_spec(opts),
      BuildWriter.child_spec(nil),
      LockIndexer.child_spec(nil)
    ], strategy: :one_for_one)

    mix_exs_paths =
      IO.read(:stdio, :all)
      |> String.trim()
      |> String.split("\n")
      |> Enum.map(&Path.absname/1)
    
    # Create filegroup at root for all mix.exs files
    BuildWriter.emit(Path.absname("BUILD"), [
          %Bazel.Rule{rule: "filegroup",
                      params: [
                        name: "all_mix_exs",
                        srcs: Enum.map(mix_exs_paths, &Labeler.fully_qualified/1),
                        visibility: ["//visibility:public"]]}])
    
    Mix.start()
    Code.compiler_options(ignore_module_conflict: true)

    # Every mix project BUILD needs a few things regardless of mix_env 
    for p <- mix_exs_paths do
      BuildWriter.emit(Path.join(Path.dirname(p), "BUILD"), [
            %Bazel.Load{from: "@rules_elixir//impl:mix_rules.bzl",
                        symbols: ["mix_project2", "mix_project_in_context", "mix_config_group"]},
            %Bazel.Call{func: "exports_files",
                        args: [["mix.exs", "mix.lock"], ["//visibility:public"]]}])
    end

    # Read every mix.exs in each environment that was requested
    which_envs = if [] == run_in_mix_envs, do: ["prod"], else: run_in_mix_envs
    here = File.cwd!()
    env_to_infos = for env_name <- which_envs do
      mix_env = String.to_atom(env_name)
      Mix.env(mix_env)
      {mix_env, map_progress(mix_exs_paths, "Load mix.exs (#{mix_env})", &read_mix_exs/1)}
    end
    File.cd!(here)    

    # Run for each environment
    for {_, infos} <- env_to_infos, do: run(infos)

    create_elixir_filegroups(for {_, infos} <- env_to_infos, i <- infos, do: i)
    
    locks_rules = for {_app, attrs} <- LockIndexer.attrs_for_all() do
      %Bazel.Rule{rule: attrs.rule, params: attrs |> Map.delete(:rule) |> Map.put(:name, LockIndexer.short_name(attrs))}
    end

    BuildWriter.emit(output_bzl, [
          %Bazel.Load{from: "@rules_elixir//impl:mix_deps_rules.bzl", symbols: ["hex_package", "mix_git_repository"]},
          %Bazel.Def{name: "elixir_autogenerated_repos", body: locks_rules}
        ])
    
    IO.puts("Flush BUILD files")
    BuildWriter.flush()
  end

  # Name of the filegroup target that is created for each path appearing in elixirc_paths (in all envs)
  def elixirc_paths_filegroup(path), do: "elixirc_paths_" <> String.replace(path, "/", "_")
  def elixirc_paths_target(path), do: ":" <> elixirc_paths_filegroup(path)

  # Create one fully-expanded filegroup for each elixirc_paths entry.
  # Basically, we are doing the globs at BUILD-file generation time, as opposed to bazel analysis time.
  def create_elixir_filegroups(infos) do
    all_elixirc_paths = for(
      info <- infos,
      ecp <- info.config[:elixirc_paths]
    ) do
        {info.dir, ecp}
    end
    
    project_elixirc_paths = 
      all_elixirc_paths
      |> Enum.group_by(fn {dir, path} -> dir end, fn {dir, path} -> path end)

    for {dir, all_paths} <- project_elixirc_paths do
      for p <- Enum.uniq(all_paths) do
        bfn = Path.join(dir, "BUILD")
        BuildWriter.emit(bfn, [
              %Bazel.Rule{rule: "filegroup",
                          params: [
                            name: elixirc_paths_filegroup(p),
                            # glob everything, instead of just .ex, to make sure we catch any .eex or other
                            # "resource" files that you want to keep in-tree and read at compile time
                            srcs: (for fp <- Path.wildcard("#{dir}/#{p}/**/*"), File.regular?(fp) do
                                       String.replace_prefix(fp, "#{dir}/", "")
                                   end)]}])
      end
    end
  end

  def run(project_infos) do
    apps_path_map = for info <- project_infos, !is_nil(info.apps_path), into: %{} do
      {info.apps_path, Labeler.fully_qualified(Path.join(info.dir, info.mix_env))}
    end

    all_mix_exs_label = Labeler.at_root("all_mix_exs")
    for i <- project_infos do
      # Check if we are a member of any umbrella projects
      umbrella_parent = for {apps_path, target} <- apps_path_map, String.starts_with?(i.dir, apps_path), do: target
      # Some people use the umbrella lockfile outside of the umbrella
      external_lockfile = if !String.starts_with?(i.mix_lock, i.dir), do: [Labeler.fully_qualified(i.mix_lock)]
      # Same goes for config
      external_config = if !String.starts_with?(i.config_exs_path, i.dir) do
        # COMMENTED OUT: Fancy code to find out the actual right answer for where we are getting our config
        # config_project = Enum.find(project_infos, fn j ->
        #   # Find the project that has the same config path, but actually does own it.  n-squared ;p
        #   j.config_exs_path == i.config_exs_path && String.starts_with?(j.config_exs_path, j.dir)
        # end)
        # REPLACED WITH: it's always the umbrella in practice ;)
        "@brex//:#{i.mix_env}"
      end
      bfn = Path.join(i.dir, "BUILD")
      BuildWriter.emit(bfn, [
            %Bazel.Rule{
              rule: "mix_project2",
              params: [
                name: i.mix_env,
                app: i.name,
                mix_env: i.mix_env,
                elixir_sources: i.elixirc_filegroups,
                umbrella: Enum.at(umbrella_parent, 0),
                extra_build_files: external_lockfile,
                imports_config_from: external_config,
                build_path: i.build_path,
                deps_path: i.deps_path]}])
    end

    for i <- project_infos, i.name != "umbrella", File.exists?(i.mix_lock) do
      images_option = get_in(i.config, [:rules_elixir_config, :generate_images])
      images? = if !is_nil(images_option), do: images_option, else: !is_nil(i.container_push_repo)
      BuildWriter.emit(Path.join(i.dir, "BUILD"), [
            %Bazel.Load{from: "@rules_elixir//impl:mix_reader.bzl", symbols: ["mix_reader"]},
            %Bazel.Rule{
              rule: "mix_reader",
              params: [
                name: autodeps_target(i),
                root_mix_project: i.label,
                all_mix_exs: all_mix_exs_label,
                lock: LockIndexer.label_for_lock(i.mix_lock),
                generate_tests: i.has_tests,
                generate_images: images?,
                elixir_sources: i.elixirc_filegroups,
                container_push_repo: i.container_push_repo,
                visibility: ["//visibility:public"]]}])
    end
  end

  defp autodeps_target(info) do
    "autodeps_#{info.mix_env}"
  end

  def read_mix_exs(mix_exs_path) do
    File.cd!(Path.dirname(mix_exs_path))

    # # Code.compile_file(Path.basename(mix_exs_path))
    r = get_mix_project_info!()
    Mix.ProjectStack.pop()
    r
  end

  def get_mix_project_info!() do
    here = File.cwd!()
    Code.compile_file("mix.exs")
    config = Mix.Project.config()
    env_name = to_string(Mix.env())
    mix_lock_path = Path.expand(Path.absname(config[:lockfile]))
    LockIndexer.ingest(mix_lock_path)
    %{
      name: to_string(config[:app] || :umbrella),
      mix_env: env_name,
      config: config,
      dir: here,
      has_tests: env_name == "test" && [] != Path.wildcard("test/**/*_test.exs"),
      container_push_repo: infer_container_repository_name(),
      label: Labeler.fully_qualified(Path.join(here, env_name)),
      apps_path: (if config[:apps_path], do: Path.absname(config[:apps_path])),
      elixirc_filegroups: Enum.map(config[:elixirc_paths], &elixirc_paths_target/1),
      config_exs_path: Path.expand(Path.absname(config[:config_path])),
      build_path: Labeler.relative_to_root(Mix.Project.build_path(config)),
      deps_path: Labeler.relative_to_root(Mix.Project.deps_path(config)),
      mix_lock: mix_lock_path,
      # mix_exs: mix_exs_path
    }
  end

  
  def read_lockfile(lockfile_path) do
    text = File.read!(lockfile_path)
    {:ok, ast} = Code.string_to_quoted(text, warn_on_unnecessary_quotes: false)
    {locks_map, _bindings} = Code.eval_quoted(ast)
    locks_map
  end

  def infer_container_repository_name() do
    with({:ok, chart} <- File.read("k8s/chart/values.yaml"),
         [_match, _name, name] <- Regex.run(~r/repository:(.*)\/(.*)/, chart)) do
      name
    else
      _ -> nil
    end
  end

  defp map_progress(xs, name, f) do
    n = Enum.count(xs)
    denom = to_string(n)
    chars = byte_size(denom)

    IO.write(:stderr, [name, "..."])
    mapped = Enum.map(Enum.with_index(xs), fn {e, idx} ->
      r = f.(e)
      IO.write(:stderr, [
            "\r", IO.ANSI.clear_line(),
            name, "... ",
            String.pad_leading(to_string(idx), chars), "/", denom])
      r
    end)
    IO.puts(:stderr, ["\r", IO.ANSI.clear_line(), name, "... done"])

    mapped
  end

end
