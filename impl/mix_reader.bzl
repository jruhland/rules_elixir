load("@rules_elixir//impl:providers.bzl", "MixDepsCached", "MixLock", "MixProject")
load("@rules_elixir//impl:mix_lock.bzl", "add_mix_deps_to_args")

def _mix_reader_rule_impl(ctx):
    output_dir = ctx.actions.declare_directory("gen")
    output_cached_deps = ctx.actions.declare_file(ctx.label.name + "_deps.bin")
    args = ctx.actions.args()

    # Cache the deps in a separate action.
    # Return the cached deps to downstream in a Provider and also consume them in the
    # mix_reader step which generates the updated BUILD file.
    cd_args = ctx.actions.args()
    cd_args.add("--output", output_cached_deps.path)
    cd_args.add("--mix-env", ctx.attr.root_mix_project.label.name)
    cd_args.add("--subdir", ctx.attr.root_mix_project.label.package)
    add_mix_deps_to_args(cd_args, ctx.attr.lock[MixLock])

    ctx.actions.run(
        executable = ctx.executable._cached_deps,
        inputs = depset(
            direct = ctx.files.all_mix_exs,
            transitive = [
                ctx.attr.lock[MixLock].all_files,
                ctx.attr.root_mix_project[MixProject].build_files,
            ],
        ),
        outputs = [output_cached_deps],
        arguments = [cd_args],
        use_default_shell_env = True,
    )

    args = ctx.actions.args()

    args.add("--output-dir", output_dir.path)
    args.add("--mix-deps-cached", output_cached_deps.path)
    args.add("--mix-env", ctx.attr.root_mix_project.label.name)
    args.add("--subdir", ctx.attr.root_mix_project.label.package)
    args.add("--workspace-name", ctx.workspace_name)
    args.add("--bazel-package", ctx.attr.root_mix_project.label.package)

    args.add("--deps-meta", str(ctx.attr.lock.label))
    add_mix_deps_to_args(args, ctx.attr.lock[MixLock])
    if ctx.attr.generate_tests:
        args.add("--generate-tests")
    if ctx.attr.generate_images:
        args.add("--generate-images")
    if ctx.attr.container_push_repo != "":
        args.add("--container-push-repo", ctx.attr.container_push_repo)

    ctx.actions.run(
        executable = ctx.executable._mix_reader,
        inputs = depset(
            direct = [output_cached_deps] + ctx.files.all_mix_exs,
            transitive = [
                ctx.attr.lock[MixLock].all_files,
                ctx.attr.root_mix_project[MixProject].build_files,
                depset(ctx.files.existing_build_files),
                depset(ctx.files.elixir_sources),
            ],
        ),
        outputs = [output_dir],
        arguments = [args],
        use_default_shell_env = True,
    )

    return [
        DefaultInfo(
            files = depset([output_dir]),
        ),
        MixDepsCached(
            mix_deps_cached = output_cached_deps,
        ),
    ]

mix_reader_rule = rule(
    _mix_reader_rule_impl,
    attrs = {
        "root_mix_project": attr.label(
            doc = """
            The label of the source MixProject that we should generate real a build file for.
            """,
        ),
        "all_mix_exs": attr.label(
            allow_files = True,
            doc = """
            Filegroup with every other mixfile in the repo that we could possibly depend on.  
            Since we don't know yet what we do depend on, we can't rule anything out, and we need them all. 
            """,
        ),
        "deps_dir": attr.string(
            doc = """
            The directory name under which the repo rule(s) have chosen to download the actual deps.
            """,
        ),
        "lock": attr.label(
            providers = [MixLock],
            doc = "Link to the mix_lock rule, which is generated by the repo rule(s)",
        ),
        "generate_tests": attr.bool(
            doc = "Whether we should generate a mix_test target for this project",
        ),
        "generate_images": attr.bool(
            doc = "Whether we should generate a docker_elixir target for this project",
        ),
        "container_push_repo": attr.string(
            doc = "If given/non=empty, a container_push will be generated which pushes to this repo",
        ),
        "elixir_sources": attr.label_list(
            allow_files = True,
            doc = "kind of a hack, we need to see the same set of sources so we can regenerate the BUILD file again properly",
        ),
        "existing_build_files": attr.label_list(allow_files = True),
        "_mix_reader": attr.label(
            default = Label("@rules_elixir//impl/tools:mix_reader"),
            executable = True,
            cfg = "host",
        ),
        "_cached_deps": attr.label(
            default = Label("@rules_elixir//impl/tools:cached_deps"),
            executable = True,
            cfg = "host",
        ),
    },
)

def mix_reader(name = None, **kwargs):
    mix_reader_rule(
        name = name,
        existing_build_files = native.glob(["BUILD", "BUILD.autogenerated.bzl"]),
        **kwargs
    )
